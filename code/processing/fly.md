# Processingの基礎
## ウィンドウを作成
### size(w, h): 幅w, 高さh のウィンドウを作成する
  * w: 整数値, 幅（ピクセル）
  * h: 整数値, 高さ（ピクセル）
### Processingの座標系
  * ウィンドウの左上: 原点(0,0)
  * 横方向: X軸方向、右向きが正方向
  * 縦方向: Y軸方向、下向きが正方向
## Processingでの描画方法
### 関数を実行することで、Processingで描画できる
1. 点を描く、線を描く、図形を描く関数
2. 線の色・太さ、塗りつぶしなどのオプションを決める関数
### ウィンドウの大きさを指定して、オプションを決めた後、描画するプログラムを書くのが、Processingの基本
### 線を描くサンプルプログラム
```
size(600, 400)                      # ウィンドウの大きさ
strokeWeight(4.5)                   # 線の太さ
stroke(50.0, 60.0, 200.0)           # 線の色
line(100.0, 100,0, 300.0, 200.0)    # 線を描画
```
## 基本的な描画関数の紹介
### strokeWiegth(w): 線（枠線）の太さをwに設定する
### noStroke(): 線（枠線）を描画しない設定にする
### line(x0, y0, x1, y1): 直線を引く
  * 座標(x0, y0)から、座標(x1, y1)へ線を描画
### rect(x, y, w, h): 長方形を描く
  * 四角形の左上頂点(x, y)とし、幅w、高さhの長方形
### ellipse(x, y, w, h): 楕円を描く
  * 中心座標(x, y)とし、幅w、高さhである楕円を描画
  * 幅と高さを同じ値にすると円となる
### stroke(r, g, b): 線（枠線）の色を設定
### fill(r, g, b): 塗りつぶしの色を設定
  * 赤成分r、緑成分g、青成分bは0から255の値とする
### background(r, g, b): 背景色を設定
  * 赤成分r、緑成分g、青成分bは0から255の値とする
### background(w): 背景色を設定
  * １つの値しか指定しない場合、0（黒）〜255（白）の範囲でグレースケールの背景となる
## 描画の注意
### プログラムは上から下に順番に実行されるため、最初に描いた図形が最背面、最後に描いた図形が最前面となる
### 設定した線の太さ、線の色、塗りつぶし色に関しては、設定を変更しない限り、状態が継続される
### ウィンドウを作成した後、ウィンドウの幅は変数width、ウィンドウの高さは変数heightとして利用できる
  * これらの変数は、Processingが定義している変数なので宣言することなく利用できる
  * ウィンドウの中心の座標は(width/2, height/2)となる
## 練習問題
1. 日本の国旗を描いてください
    * 幅：高さ　＝　３：２
2. オランダの国旗を描いてください
    * 幅：高さ　＝　３：２
3. スイスの国旗を描いてください
    * 幅：高さ　＝　１：１
## 繰り返し処理との融合
### グラデーションの描画例
```
size(810, 300)      # 画面の大きさ
noStroke()          # 枠線を消す
# 色を青色から赤色に変えながら81個の長方形を描画する
for i in range(81):
    fill(i * 255 / 80.0, 0, 255 - i * 255 / 80)
    rect(i * 10, 0, 10, 300)
```
## アニメーションの基礎
### 静止画を高速に切り替えることでアニメーションが実現できる
  * アニメーションにおいて、１秒間あたりに処理させる静止画像（フレーム）数のことをフレームレートとよぶ
  * 単位: fps (60fpsは1秒間に60フレーム切り替えている）
### Processingも同様に、各フレームを高速に切り替えることで、アニメーションを実現する
  * 初期化を行うsetupブロック（setup関数）と、フレームを描画するdrawブロック（draw関数）を定義する
## アニメーションプログラム概要
### setup: 最初に１度だけ実行される
  * ウィンドウのサイズ設定など１度だけ必要な処理をこの中に記述する
## draw: フレームを表示するたびに実行される
  * ここで記載していることがアニメーションで表示される
  * デフォルトでは1秒間に60回実行される
```
def setup():
    # 初期化処理をここに書く
def draw():
    # フレームごとの処理をここに書く
```
## アニメーション例１
```        
def setup():    # 1回だけ実行される
    size(255, 255)          # ウィンドウのサイズ

def draw():     # setupを終えた後、繰り返し実行される
    background(192)         # 背景色で塗りつぶす
    z = frameCount % 256
    fill(z, 255 - z, 255)   # 円の塗りつぶしの色を決める
    ellipse(z, z, 30, 30)   # 円を描画する
```
### frameCount: Processingが用意している特別な変数
  * プログラムが開始されてから表示されたフレーム数を格納
  * 0から始まり、drawが終わると１つ増える
  * 剰余を利用して、変数zの値が0から255となるように設定
## アニメーション例２
```        
def setup():    # 1回だけ実行される
    size(255, 255)          # ウィンドウのサイズ

def draw():     # setupを終えた後、繰り返し実行される
    z = frameCount % 256
    fill(z, 255 - z, 255)   # 円の塗りつぶしの色を決める
    ellipse(z, z, 30, 30)   # 円を描画する
```
### アニメーション例１のプログラムから「background(192)」を削除して実行した場合、どのようになるか確かめてください。また、どうしてそうなるのか、理由を考えてください。
## アニメーション失敗例
```
def setup():    # 1回だけ実行される
    size(255, 255)  # ウィンドウのサイズ

def draw():     # setupを終えた後、繰り返し実行される
    x = 0
    background(192) # 背景色で塗りつぶす
    fill(0, 200, 200)   # 円の塗りつぶしの色を決める
    ellipse(x, x, 30, 30)   # 円を描画する
    x += 1
```
### このプログラムは、アニメーションとしては成立しない
  * その理由を考えてみてください
## グローバル変数
### setup関数、draw関数の外側で変数を宣言することで、プログラム（setup関数、draw関数）のどこからでも使用可能な変数のこと
  * プログラムが終わるまで、変数は存在する
  * draw関数が終わったとしても、値を維持できる
  * 関数の中で宣言した変数はその関数でしか利用できない
```
x = 10  # グローバル変数の宣言
def setup():
    # 初期化処理をここに書く
def draw():
    # フレームごとの処理をここに書く
```
##　グローバル変数の使い方
### 関数中からグローバル変数の値を変更する場合、グローバル変数の値を変更する関数の戦闘にglobal 変数名　と記述する必要がある
```
x = 10  # グローバル変数の宣言
def setup():
    # 初期化処理をここに書く
def draw():
    # フレームごとの処理をここに書く
    global x    # グローバル変数を変更するため
    x += 1      # グローバル変数を変更
```
## アニメーション成功例
```
x = 0   # グローバル変数の宣言
def setup():    # 1回だけ実行される
    size(255, 255)          # ウィンドウのサイズ

def draw():     # setupを終えた後、繰り返し実行される
    global x
    background(192)         # 背景色で塗りつぶす
    fill(0, 200, 200)       # 円の塗りつぶしの色を決める
    ellipse(x, x, 30, 30)   # 円を描画する
    x += 1
    x = x % 255
```
# 実践演習「ハエ叩きゲーム」
## Step0: ウィンドウを設定
### 画面の大きさ、背景色を設定する
  * 以下のプログラムでは
  * 画面の大きさを幅800、高さ800
  * 背景色を白としている
```
def setup():
    size(800, 800)  # ウィンドウのサイズ
def draw():
    background(255) # 背景色を決める
```
## Step1: ハエ叩きをマウスの位置で変更
### ハエ叩きをマウスの位置で変更できるようにする
  * Processingでは、マウスの位置を取得できる特別な変数mouseX, mouseYという変数が存在する
  * ハエ叩きの中心位置の座標を(mouseX, mouseY)にすれば良い
```
def draw():
    background(255)
    sWidth = 20         # ハエ叩きの幅
    sHeight = 20        # ハエ叩きの高さ
    fill(198, 204, 255) # ハエ叩きの色
    # ハエ叩きを描画する
    rect(mouseX - sWidth / 2, mouseY - sHeght / 2, sWidth, sHeight)
```
## Step2: ハエを動かす
### ハエの位置、速度をグローバル変数で宣言し、drawメソッドを更新する
  * 速度は1フレームで動くピクセル量となる
### x方向とy方向の変化量を指定することで、平面を1方向に移動することができる
  * 三角比、ベクトルなどの考え方で以下は自明
  * xとyの変化量が同じ場合、45度の方向で進む
### ハエの位置、速度をグローバル変数として宣言し、drawメソッドを更新する
  * 速度は1フレームで動くピクセル量となる
### グローバル変数の追加箇所
```
fX = 50 # ハエのx座標
fY = 50 # ハエのy座標
fVx = 9 # ハエのx方向に対する更新量
fVy = 2 # ハエのy方向に対する更新量

def setup():
    size(800, 800)  # ウィンドウのサイズ
```
### drawメソッドの追加箇所
```
def draw():
    global fX, fY, fVx, fVy # グローバル変数を変更する
    background(255)
    sWidth = 20             # ハエ叩きの幅
    sHeight = 20            # ハエ叩きの高さ
    fill(198, 204, 255)     # ハエ叩きの色
    # ハエ叩きを描画する
    rect(mouseX - sWidth / 2, mouseY - sHeight / 2, sWidth, sHeight)
    fill(0, 0, 0)           # ハエの色
    ellipse(fX, fY, 10, 10) # ハエを描画する
    fX += fVx               # ハエのx座標を更新する
    fY += fVy               # ハエのy座標を更新する
```
## Step 3: ハエを壁で反射させる
### 上端、下端、左端、右端にハエが衝突した場合、ハエが反射するようにする
  * 「衝突した場合」と「ハエを反射する」をプログラムで表現する
### 「衝突した場合」のプログラム表現
  * 上端に衝突する: ハエのy座標 < 0
  * 下端に衝突する: ハエのy座標 > ウィンドウ高さ
  * 左端に衝突する: ハエのx座標 < 0
  * 右端に衝突する: ハエのx座標 > ウィンドウ幅
### ハエを反射するをプログラムで表現するために
  * 上端に衝突した場合、x方向の速度は変化せず、y方向に速度は逆になる
  * 下端に衝突した場合、x方向の速度は変化せず、y方向に速度は逆になる
  * 左端に衝突した場合、x方向の速度は逆になり、y方向に速度は変化しない
  * 右端に衝突した場合、x方向の速度は逆になり、y方向に速度は変化しない
### まとめると
  * 上端・下端に衝突した場合（ハエのy座標が0より小さい場合、または、ウィンドウ高さより大きい場合）、x方向の速度は変化せず、y方向の速度は逆になる
  * 左端・右端に衝突した場合（ハエのx座標が0より小さい場合、または、ウィンドウ幅より大きい場合）、x方向の速度は逆になり、y方向の速度は変化しない
```
def draw():
    # 途中から
    fill(0, 0, 0)               # ハエの色
    ellipse(fX, fY, 10, 10)     # ハエを描画する
    fX += fVx                   # ハエのx座標を更新する
    fY += fVy                   # ハエのy座標を更新する

    if fY < 0 or fY > height:   # 上下端衝突
        fVy *= -1
    if fX < 0 or fX > width:    # 左右端衝突
        fVx *= -1
```
## Step 4: ハエ叩きとハエの衝突判定
### ハエと壁との衝突判定を参考にして、ハエ叩きとハエの衝突判定を行う
  * ハエ叩き（四角形）の内部にハエが存在するかどうかを条件とすれば良い
### ハエ叩きの左端と上端の座標を求めるとプログラムしやすい
  * ハエ叩きの幅と高さから、ハエ叩きの右端と下端の座標を求めることができる
### 下記のプログラムは衝突したと判断した場合、ハエの位置、速度をランダムな値にしている
  * random(n); 0以上n未満の実数を返す
  * 座標値は整数なので、整数に変換する
```
def draw():
    # 途中から
    if fX < 0 or fX > width:        # 左右端衝突
        fVx *= -1

    sLeft = mouseX - sWidth / 2     # ハエ叩きの左端座標
    sRight = mouseX + sWidth / 2    # ハエ叩きの右端座標
    sTop = mouseY - sHeight / 2     # ハエ叩きの上端座標
    sBottom = mouseY + sHeight / 2  # ハエ叩きの下端座標
    # ハエ叩きとハエの衝突（衝突後、ハエの位置と速度を変更する）
    if sLeft <= fX and sRight >= fX and sTop <= fY and sBottom >= fY:
        fX = int(random(width + 1))
        fY = int(random(height + 1))
        fVx = int(random(10)) + 1
        fVy = int(random(10)) + 1
```
## Step 5: 文字列によるインタラクション
### 画面に文字列を出力させ、ゲームの見栄えを良くする
  * ハエ叩きとハエが衝突した回数を表示する
  * 衝突した回数を保存する変数はグローバル変数とする
### Processingでは、以下の方法で文字列を画面に出力できる
  * textSize(size): 文字の大きさをsizeにする
  * text(data, x, y): 文字列dataを座標(x, y)に出力する
```
count = 0   # 衝突回数
def draw():
    global fX, fYm fVx, fVy, count
    # 中略
    # ハエ叩きとハエの衝突（衝突後、ハエの位置と速度を変更する）
    if sLeft <= fX and sRight >= fX and sTop <= fY and sBottom >= fY:
        # 中略
        fVy = int(random(10)) + 1
        count += 1  # 衝突数を増やす
    # 衝突数を表示する
    textSize(16)
    text(str(count), 20, 20)    # 文字列に変換する
```
## 課題（ゲームの改造）
  * ハエを一定数倒せば、ゲームクリアにする
  * ハエの数を増やす
  * ハエの移動スピードを変化させる
  * ハエ叩きも進入禁止領域を定義し、ハエ叩きがそこに触れるとゲームオーバー」にする
  * 上記以外でも自由な発想でゲームを改造してください
