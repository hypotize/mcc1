# processing入門２（簡単なゲームを作ろう）
前回勉強したprocessingを使って簡単なゲームを作ってみましょう。
## processingの実行
まずは、ターミナルを開いて、以下のコマンドを実行しましょう
```
cd mcc1
git pull
```
次に、アプリから「processing」を実行し、ファイル/開くで
home/mcc1/code/processingの下にある「ball」を指定します。
## 最初のプログラム
processingの編集用画面に以下のようなプログラムが表示されます。
```
w = 500     # 画面の幅
h = 500     # 画面の高さ
dx = 1      # x方向（左右方向）の移動量
dy = 1      # y方向（上下方向）の移動量
r = 20      # 円（ボール）の直径
x = r / 2   # ボールの最初のx座標（位置）
y = h / 2   # ボールの最初のy座標（位置）

def setup():    # 最初に１回だけ呼ばれる関数
    size(w, h)  # 画面サイズの設定

def draw():             # 1秒に60回（変更可能）呼ばれる関数
    global x, y         # 変更する値
    background(0)       # 背景色（0は黒）
    noStroke()          # 枠線は書かない
    fill(255)           # 塗りつぶす色（255は白）
    ellipse(x, y, r, r) # 楕円を描く（x座標、y座標、x方向の直径、y方向の直径）を指定、x方向の直径とy方向の直径が等しければ円になる
    x += dx             # ボールのx座標を移動量だけ動かす
    y += dy             # ボールのy座標を移動量だけ動かす
```
では実行ボタン(▶)を押して、実行してみましょう。
黒い画面に白い円（ボール）が左中央から右下に動き、画面の外に消えていきます。
## プログラムの説明
前回の復習も兼ねて、このプログラムの内容を説明します。

プログラムの中で、#より右の部分はコメントといって、プログラムではない単なる説明文です。

まずプログラム先頭の以下の部分は、色々な値を変数に定義しています。
定義している内容はコメント文を参考にして下さい。
```
w = 500     # 画面の幅
h = 500     # 画面の高さ
dx = 1      # x方向（左右方向）の移動量
dy = 1      # y方向（上下方向）の移動量
r = 20      # 円（ボール）の直径
x = r / 2   # ボールの最初のx座標（位置）
y = h / 2   # ボールの最初のy座標（位置）
```
次に以下の`setup()`という関数の部分です。`setup()`の前についている`def`というのは`setup()`が関数であるという宣言です。

関数というのは一連の処理をまとめたもので、他のプログラムから`setup()`のように呼んで何回も同じ処理を実行させることができます。
```
def setup():    # 最初に１回だけ呼ばれる関数
    size(w, h)  # 画面サイズの設定
```
processingでは`setup()`という関数は、プログラムの最初に１回だけ呼ばれるという約束になっています。この中では画面サイズの指定など、プログラムの最初に１回しか実行しない処理を記述します。

最後に、`draw()`という関数です。
この関数は`setup()`という関数が呼ばれた後、何回も繰り返し呼ばれます。通常は1秒間に60回呼ばれることになっています。（ちなみに、1秒間に何回呼ばれるかを`setup()`関数の中で変更することも可能です）
```
def draw():             # 1秒に60回（変更可能）呼ばれる関数
    global x, y         # 変更した値を保持する
    background(0)       # 背景色（0は黒）
    noStroke()          # 枠線は書かない
    fill(255)           # 塗りつぶす色（255は白）
    ellipse(x, y, r, r) # 楕円を描く（x座標、y座標、x方向の直径、y方向の直径）を指定、x方向の直径とy方向の直径が等しければ円になる
    x += dx             # ボールのx座標を移動量だけ動かす
    y += dy             # ボールのy座標を移動量だけ動かす
```
`draw()`関数内では、いろいろな図形の描画を行います。

通常は関数内で変数の値を変更しても、その関数が終了してしまったら、その変更は保持されません。関数が終わっても変更を保持したければ`global`で宣言をする必要があります。

今回のプログラムでは、`draw()`関数の中でボールの位置を少しずつ増やして移動させたいので、増やした値が消えないように、ボールの位置を表すx, yという変数を`global`で宣言しています。

`background()`という関数は背景色を塗りつぶつ関数です。この関数を指定しないと毎回画面が背景色で塗られないので、この後描画した図形がどんどん上書きされて重なって描画されてしまいます。試しに`background()`の前に#を入れて実行してみてください。（#を入れると#以降のその行がコメントとなり、プログラムとしては無効になります）

実行すると円が移動するのではなく、円の大きさの太い線が動いていくようになります。これは円が移動しながら重ね書きされるからです。

`background()`の`()`の中に指定する値（今回は0）のことを関数の引数と呼びます。`background()`関数では、引数として色を指定します。`background`関数の引数には以下のような種類の指定方法があります。
* 1個だけ指定する
    1. 単色（0: 黒　～　255: 白）
* 2個指定する
    1. 単色（0: 黒　～　255: 白）
    2. 透明度（0: 透明　～　255: 不透明）
* 3個指定する
    1. 赤（0～255）
    2. 緑（0～255）
    3. 青（0～255）
* 4個指定する
    1. 赤（0～255）
    2. 緑（0～255）
    3. 青（0～255）
    4. 透明度（0: 透明　～　255: 不透明）

複数個指定する場合、引数と引数の間はコンマ(,)で区切ります。

今回は0なので、単色の黒を指定しています。

上記の色々な指定方法で指定して背景がどうなるか試してみましょう。（なお、今回は背景なので、透明度は指定してもあまり意味がありません。透明度はこの後の図形の時使用すると、図形が透けて背景が見えたりします）

`noStroke()`という関数はこの後描画する図形の枠線を塗らないという指定です。
図形の枠線を塗りたい場合は`noStroke()`の代わりに`stroke()`という関数を使います。その際は、引数に色を指定します。色の指定方法は`background()`関数で説明したものと同じです。

`noStroke()`の部分を`stroke()`に変え、引数に色々な色を指定してボールがどのようになるか試してみましょう。（枠線が細いので、背景を白にした方が分かりやすいです）

`fill()`という関数はこの後描画する図形の塗りつぶし色を指定します。引数は色で、その指定方法は`background()`関数で説明したものと同じです。

ここでは単色の白(255)を指定していますが、引数に色々な色を指定してボールがどのようになるか試してみましょう。（ここで透明度を指定すると背景が透けて見えます）

`ellipse()`という関数は楕円を描画する関数です。引数には以下の4つの値を指定します。
1. 描画する楕円の中心のx座標（位置）
2. 描画する楕円の中心のy座標（位置）
3. 描画する楕円のx方向（左右方向）の直径
4. 描画する楕円のy方向（上下方向）の直径

引数3のx方向の直径と引数4のy方向の直径の値を同じ値に指定すれば、円になります。
今回ボールは円なので両方に直径rを指定しています。

引数1と引数2の値x, yは円の中心の位置を指定します。
xの初期値をr / 2にしたのは、半径分右にずらすことで円全体が見える形で左端に表示させるためです。初期値を0にすると半円の状態から表示されることになります。
yの初期値は画面の中央の高さに表示したいのでh / 2を指定しています。

最後にx, yの値にdx, dyの値を足しこんで更新することで、毎回`draw()`関数が呼ばれるたびに、円の位置が少しずつ右下に動いて表示されるようになります。
`x += dx`、`y += dy` はそれぞれ `x = x + dx`、`y = y + dy` と同じ意味です。

長くなりましたが、これでプログラムの意味が理解できたと思います。
## ボールを反射させる
今のプログラムのままでは、ボールが画面の下端まで到達するとそのまま消えてしまいます。画面の端を壁とみなして、ボールを反射するようにしてみましょう。
### ボールが画面の下端に衝突したかどうかの判定
画面は、左上が(0,0)、右上が(w,0)、左下が(0,h)、右下が(w,h)という座標になっています。すなわち、x座標は左端が0、右端がw（画面の幅）、y座標は上端が0、下端がh（画面の高さ）です。
従って、画面の下端とはy座標がhということになります。

次に画面の下端に衝突するボールについて考えてみましょう。ボールの座標値はx,yという変数に入っています。ただこの値はボールの中心の位置です。ボールが画面の下端にぶつかるということはボールの下端のy座標が画面の下端のy座標より大きくなるということです。

ボールの下端のy座標は、ボールの中心のy座標値にボールの半径（直径の半分 = r / 2）を足した値です。

従って `x + r / 2 > h` が成り立つ時、ボールの下端が画面の下端に衝突したことになります。
### 衝突したら、ボールを反射させる
画面の下端でボールが反射するとは、ボールが画面の下端に衝突したら、ボールのy方向の移動方向が逆方向にするということを意味しています。
すなわち、`dy = -dy` にするということです。この際、x方向の移動量は変わりません。
### ボールを反射させるプログラムを作ろう
「（条件）だったら（処理）する」というのはプログラミングでは条件文と呼び、以下のようにプログラミングします。
```
if 条件:
    処理
```
では、以上のことを踏まえて、ボールを反射させるプログラミングを追加してください。
追加する場所は`draw()`関数の一番最後になります。

追加したら、実行してボールが反射するか確認してください。
#### 注意
`dy` を変更させるので、この変更を消さないためには`dy`を`global`宣言に加える必要があります。
## 画面右端でも反射させる
画面下端でボールを反射させるようにすると、今度は画面右端で消えてしまいます。画面下端で反射させたと同様、右端でも反射させるようにしてください。
### ヒント
画面右端にぶつかるというのはボールの右端のx座標(x + r / 2)が画面右端のx座標(w)を超えたらということ。右端で反射するということはy方向の移動量はそのままでx方向の移動量だけ反転する(dx = -dx)ということです。
## 画面の上端、画面の左端でも反射させる
画面の全ての端でボールが反射するようにしてください。
### ヒント
画面上端はy座標が0、画面左端はx座標が0、画面上端にぶつかるのはボールの上端y座標(y - r / 2)、画面左端にぶつかるのはボールの左端y座標(x - r / 2)です。反転は画面の上下ではy移動量のみ反転、画面の左右ではx移動量のみ反転させます。

全てのプログラミングが完成したら、実行してボールがずっと反射し続けているか確認してください。
## 条件文を結合する
画面上端の反射と画面下端の反射は、反射の条件は異なりますが、反射する処理内容は同一です。このような場合、`or`という演算子を使って条件と条件をまとめて１つの条件文に結合させることができます。
```
if 条件1 or 条件2:
    処理
```
のように書くと、「（条件1）または（条件2）なら（処理）を行う」という意味になります。

この仕組みを使うと
* ボールが画面上端にぶつかるまたは画面下端にぶつかるなら、y方向の移動量を反転させる
* ボールが画面左端にぶつかるまたは画面左端にぶつかるなら、x方向の移動量を反転させる

というように条件文を結合させて４つあった条件文を２つの条件文に整理することができます。
## マウスに追従するバーを作る
プレイヤーがボールを跳ね返すためのバーを作ります。このバーはプレイヤーが動かせるよう、マウスに追従するようにします。
### バーを表示する
バーは四角形なので`rect()`関数で描画します。この関数の引数は以下の通りです。
1. 四角形の左上のx座標
2. 四角形の左上のy座標
3. 四角形の幅
4. 四角形の高さ

`rect()`関数についても`ellipse()`関数と同様に枠線の有無や色、塗りつぶしの色等の設定を行うと、その内容が反映されます。
今回は、これらの設定はボールで設定したものをそのまま使うものとして、特に追加で指定しないこととします。

四角形の幅は
```
bar_w = 100
bar_h = 30
```
と予め設定しておきます。

四角形のx,y座標はマウスと追従するよう、マウスのx,y座標であるmouseX, mouseYという値を設定します。

`draw()`関数内でボールの描画を行う`ellipse()`関数の直後に、上記の`rect()`関数を追加して、マウスに追従するバーを表示させ、実際にマウスに追従することを確認してください。
### バーの中央にマウスが追従するように変更する
`rect()`関数の第１、第２引数の座標値は四角形の左上の位置なのでマウスの位置はバーの四角形の左上の位置になっています。

マウスの位置がバーの四角形の中央の位置になっている方が自然なので、そうなるように変更してください。
#### ヒント
四角形の中央の座標をx, yとすると四角形の左上の座標はx-幅/2, y-高さ/2になります。
## バーにボールが衝突すると反射するようにする
このままではバーに衝突してもボールは変化せずすり抜けてしまっているので、バーに衝突したらボールが反射するように変更します。

今回は、ボールの下端がバーの上端に衝突した時だけボールとバーが衝突することとします。
### バーにボールが衝突する条件
ボールの下端がバーの上端に衝突する条件は以下の４つの条件が全て満たされたときです。
* ボールの下端のx座標がバーの左端のx座標より大きい
* ボールの下端のx座標がバーの右端のx座標より小さい
* ボールの下端のy座標がバーの上端のy座標より大きい
* ボールの下端のy座標がバーの下端のy座標より大きい

条件1かつ条件2のように「かつ」で条件を繋げる場合は`and`という演算子を使い、以下のように書きます。
```
if 条件1 and 条件2:
    処理
```
条件が4つあれば、４つの条件を全て`and`で繋げばよいことになります。
#### ヒント
* ボールの下端のx座標は、x
* ボールの下端のy座標は、y + r / 2
* バーの左端のx座標は、mouseX - bar_w / 2
* バーの右端のx座標は、mouseX + bar_w / 2
* バーの上端のy座標は、mouseY - bar_h / 2
* バーの下端のy座標は、mouseY + bar_h / 2
### バーに衝突したら反射する
今回は、ボールの下端がバーの上端に衝突した時だけボールとバーが衝突したことにするので、衝突したら、y方向の移動量だけ逆方向にすればよいことになります。

それでは、バーに衝突したら反射するようにプログラムを変更してください。

プログラムを変更したら、バーの上端でボールが反射するか確認してください。（ちなみに、今回の変更では、バーの下端側から来たボールもバーの中に潜って後、バーの上端で下方向に反射します）
## 画面の下端ではボールが反射せずに進み、ボールが下端を超えたらゲームオーバーにする
バーによってボールを上方向に反射できるようになったので、画面下端ではボールを反射しないようにして、ボールが画面の下端を超えたら、ゲームオーバーにするようにします。
### 画面の下端では反射しないようにする
画面の上下左右端で反射している処理のうち、下端の条件だけ削除します。
### ボールが下端を超えたら
ボールが下端を超えたらという条件は、反射の場合の条件とは異なり、完全にボールが画面の下端から消えたという条件にします。
ボールが完全に画面の下端を超えるというのは、ボールの上端のy座標(y - r / 2)が画面の下端(h)より大きくなったことを意味します。
### ゲームオーバーにする
今回は、ゲームオーバーになったら赤い文字で画面中央に「GAME OVER!!」と表示することにします。また、ゲームオーバーになったらこれ以上画面を動かす必要がないので画面の更新を停めます。
#### ヒント
* 文字を表示するには`textSize()`という関数で表示する文字の大きさを指定します。「GAME OVER!!」の文字は大きい方がいいので引数には40を指定します。
* 文字の色は`fill()`関数で指定します。色の指定の仕方は以前説明しましたが、赤い文字なら`fill(255, 0, 0)`で指定できます。
* 文字を描画するのは`text()`という関数です、第１引数は文字列でこの場合は"GAME OVER!!"になります。第２引数と、第３引数は描画位置x,yで画面中央に表示するには150, h / 2を指定します。
* 画面の更新を止めるには`noLoop()`という関数を呼びます。

実際にプログラムを変更し、ボールが下端を超えるとゲームオーバーになって画面の更新が停止することを確認してください。
## ブロックを作る
次にブロック崩しを行うためのブロックを作ります。ここでは5x5の25個のブロックを作ります。
### ブロックの描画
まずはブロックを描画します。ブロックの幅・高さはどのブロックも同一なので、プログラムの最初の部分で以下のように定義します。
```
block_w = 100
block_h = 30
```
各ブロックの描画位置x, yはそれぞれ異なるので、それぞれのブロックを`rect()`関数を25個作成すれば実現できますが、このようにすると、ブロックの描画以外にも、ボールとの衝突判定、ボールの消滅など、すべての処理を25個分作らなくてはならずとても大変です。
### 辞書とリスト（配列）の活用
ブロックのように同じものが何個もある場合、辞書とリスト（配列）を活用すると簡単に処理することが出来るようになります。
### 辞書の活用
ブロックに対する描画位置x, yのように１つのものに複数の値がある場合、辞書を使うことで一括で管理できるようになります。

辞書は`block = {'x': 0, 'y': 0}`のように書きます。

`block`辞書の`x`の値は`block['x']`で参照したり、変更したりすることができます。

この仕組みを使えばブロックを描画することは
```
rect(block['x'], block['y'], block_w, block_h)
```
のように書くことができます。
#### リスト（配列）の活用
複数のものをまとめて管理する仕組みとしてリスト（配列）があります。
```
blocks = [{'x': 0, 'y': 0}, {'x': 100, 'y': 0}]
```
のように書くと複数のブロックをまとめて管理することができます。
個々のブロックは`blocks[0]`でブロックの内容を参照したり、変更したりすることができます。（[]の中の0は何番目に格納されているかを示します）
#### 繰り返し文(for)を使う
5回繰り返して同じような処理を行う場合、`for i in range(5):`という繰り返し文を使えば簡単に5回繰り返す処理を行えます。
今回は5x5のように5回繰り返す処理をさらに５回繰り返す場合は
```
for i in range(5):
    for j in range(5):
        処理
```
のように書くことで実現できます。
### 5x5のブロックを作成する
5x5のブロックの描画位置は
```
(0,0), (block_w, 0), ...(block_w * 4, 0)
(0, block_h), (block_w, block_h), ...(block_w * 4, block_h)
..
..
(0, block_h * 4), (block_w, block_h * 4), ...(block_w * 4, block_h * 4)
```
のようになります。
ちょっと難しいですが、各座標値は
```
(block_w * j, block_h * i)　(i = 0 ～ 4, j = 0 ～ 4)
```
のように整理することができます。
先ほどの繰り返しの仕組みを使うと
```
for i in range(5):
    for j in range(5):
        (block_w * j, block_h * i)
```
で5x5の座標値を設定することが可能になります。

配列に値を追加するには、`blocks = []`のように空の配列で初期化した後、`blocks.append(値)`のようにすると配列に１つずつ値を追加できます。

また、ブロックの辞書に座標値を設定するのは
```
{'x': block_w * j, 'y': block_h * i}
```
のようにすれば、設定できます。

ここまでの仕組みを使って座標値の入ったブロック辞書を5x5=25個分`blocks`に追加するプログラムを作ってください。

なお、ブロックを作成するのは最初の１回だけなので、`setup()`関数の中で作成してください。ただし、`blocks = []`の部分は、`setup()`を呼ぶ前に設定して下さい。
### ブロックを描画する
ここまで正しくプログラミングができていれば、`blocks`というリストの中に25個の描画座標(x,y)が設定されたブロックが格納されているはずです。

それでは、このリストを使って作成したブロックを描画してみましょう。

まずリストから1個ずつ値を取り出すには
```
for block in blocks:
    blockに対する処理
```
という繰り返し文を使うことができます。
この仕組みを使うと、リストに格納された個々の値が順番に`block`という変数に設定されるのでこの変数を使用して、以下の描画処理を行うようにします。
```
rect(block['x'], block['y'], block_w, block_h)
```

ブロックの描画は`draw()`関数の中で行いますので、`draw()`関数の最後に追加してください。

プログラムを変更したら実行してみましょう。上の方が真っ白になりましたね。これがブロックです。でもこのままでは個々のブロックがくっついてしまって１つの巨大なブロックに見えてしまうので、以下のような黒い枠線を設定して個々のブロックがわかりやすいようにしましょう。
```
stroke(0)
fill(255)
```
他の変更に影響されないよう、塗りつぶしの色も指定しておきます。

それではブロックの描画処理の前に上記プログラムを追加して実行してください。
ブロックらしくなったはずです。
## ブロックに衝突したらボールが跳ね返る
今のままではボールがブロックに衝突してもブロックを突き抜けていってしまいます。

今回は、バーの時とは逆にボールの上端がブロックの下端に衝突した時、ボールとブロックが衝突したことにします。
### ブロックにボールが衝突する条件
バーの時同様に衝突する条件を整理すると、以下の条件が全て満たされた時になります。
* ボールの上端のx座標がブロックの左端のx座標より大きい
* ボールの上端のx座標がブロックの右端のx座標より小さい
* ボールの上端のy位置がブロックの上端のy座標より大きい
* ボールの上端のy位置がブロックの下端のy座標より小さい

条件文や演算子の使い方はバーの時に説明した通りです。
#### ヒント
* ボールの上端のx位置は、x
* ボールの上端のy位置は、y - r / 2
* ブロックの左端は、block['x'] 
* ブロックの右端は、block['x'] + block_w
* ブロックの上端は、block['y']
* ブロックの下端は、block['y'] + block_h
#### 注意
バーの時のようにボールの上端のx位置がブロックの左端のx座標との比較とボールの上端のx位置がブロックの右端のx座標との比較の両方を<,>で行うと、ちょうどブロックの境目にボールが衝突した時、どちらのブロックにも衝突したことにならなくなってしまうので、どちらか片方は<=のように=を付けましょう。
### ブロックに衝突したら反射する
今回は、ボールの上端がブロックの下端に衝突した時だけボールとブロックが衝突したことにするので、衝突したらy方向の移動量だけ逆方向にすればよいことになります。

それでは、ボールがブロックに衝突したら反射するようにプログラムを変更してください。

プログラムを変更したら、ブロックの下端でボールが反射するか確認してください。
## ボールがブロックに衝突したらブロックが消える
では、次にボールがブロックに衝突したらブロックが消えるようにしましょう。
### 値の追加
そのためには、ブロックにもう一つ値を追加します。

この値は「ブロックが生きているか、消えてしまったか」という値です。"alive"(生きている)という名称にし、生きているか消えてしまったかの2択なのでTrue/Falseという値（真偽といいます）とし、生きているときTrueとします。

この「真偽」という値は、以下のように条件文でそのまま使えます。
```
if True:
    処理を行う
if False:
    処理を行わない
```

では、ブロックの座標を設定している部分
```
{'x': block_w * j, 'y': block_h * i}
```
にaliveの値も追加し、Trueで初期化します。
```
{'x': block_w * j, 'y': block_h * i, 'alive': True}
```
次に、ブロックがボールにぶつかったら、y移動量を逆方向にするのに加え
```
block['alive'] = False
```
という処理も追加しましょう。

最後に、`block['alive']`がTrueの時だけ、そのブロックを描画したり、当たり判定を行ったりするように、blockの描画処理部分に条件文(if)を追加しましょう。
#### 注意
条件文(if)を追加したら、追加した後、その条件が有効である部分まで
タブをつかって行のインデントをずらす必要があります。たとえば
```
AAA
if BBB:
    CCC
DDD
```
という処理全体にXXXという条件を追加する場合は
```
if XXX:
    AAA
    if BBB:
        CCC
    DDD
```
という風に変更する必要があります。

プログラムを変更したら、実行してください。ブロックに当たるとブロックが消え、以降は消えたブロックの部分にボールがいっても反射したりはしないはずです。
## スコアの追加とゲーム終了の表示
### スコアの追加
ゲームはほぼ出来上がりましたが、折角なのでスコアを表示するようにしましょう。ブロックを１個消したら10点ずつ加算するようにしてみましょう。

まず、最初の部分にscoreという変数を追加し、0で初期化します。

次に、`draw()`関数の中でブロックとボールの衝突判定を行っている部分で、衝突した場合、scoreに10を加えます。
#### 注意
`draw()`関数の中でscoreの値を変更するので、scoreも`global`に加えるのを忘れないでください。
また10を足す処理は`score += 10`のように書けます。
### スコアの表示
追加したscoreを画面に表示しましょう。
今回は左上に20ポイントで青色で表示します。
```
textSize(20)
fill(0, 0, 255)
text("score: {}".format(score), 10, 20)
```
という処理を`draw()`関数の最後に追加します。

`"文字列 {}".format(変数)`という部分は文字列の中に変数の値を埋め込みたい時、{}のところに変数の値を入れてくれます。
### ゲームの終了
このままでは、全てのブロックを消してもゲームが終了しないので、全てのブロックを消したら、画面中央に緑色で「GAME CLEAR!!」と表示して、ゲームを終了するようにします。
### ゲーム終了の判定
ブロックが全て消えてしまったら（すなわち、ブロックの'alive'の値が全てFalseになったら）ゲーム終了です。

各ブロックに対して、block['alive']がTrueかどうかを確認し、表示したり、衝突判定をするかを判断している部分があるので、この部分を利用します。

まず、ブロックの処理を行う前にaliveという変数を用意して、これをFalseに初期化しておきます。

次に、block['alive']がTrueだったら、このalive変数をTrueにするようにします。

ブロックの処理終了後にaliveという変数がFalseのままだったら、生きているブロックは１つもないことになります。

そこで、alive変数がFalseなら、ゲーム終了処理を行います。

Falseならというのは
```
if not alive:
    ゲーム終了処理
```
のように書きます。(notはTrueではないという意味です)

ゲームの終了処理はゲームオーバー処理を参考に、文字列を「GAME OVER!!」から「GAME CLEAR!!」に変更し、色を赤(255, 0, 0)から緑(0, 255, 0)に変更してください。

プログラミングが終了したら、実行し、ブロックが全部消えたら「GAME CLEAR!!」を表示してゲームが終了するか確認してください。
## 最後に
これでプログラムは完成です。お疲れさまでした。
最後に、このプログラムの改造点を挙げておきましたので、改造に挑戦してみてください。
### 改造点
以下のような改造点が考えられますので、どうやったら改造できるか考えながら改造してみましょう。
* ブロックの高さに応じて色を変える
* スタート時のブロックの発射角度をランダムに変える
* ブロックが少なくなるとボールのスピードが上がる
* ブロックが少なくなるとバーのサイズが小さくなる
* 上方のブロックほど得点が高くなる
* バーの当たる位置によってボールの反射角度が変わる
* ゲームオーバーになったら、何かのキーを押すことで新たなゲームをスタートできる。その際、ハイスコアも表示する。
* 全部ブロックを崩した場合も何かのキーを押すことで新たなゲームをスタートでき、得点はそのまま加算される。また、新たなゲームをスタートする度に難易度が増す（ボールが早くなる、バーが小さくなる...）
* バーをマウスで動かすのではなく、上下左右の矢印キー(↑,↓,←,→)で動かすようにする

もちろん、これ以外にも自分で改良点を考えて自由に改良しても構いません。